<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/carbon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="ibm">
        <span class="ibm__brand">IBM</span> <span class="ibm__product">Cloud</span>
      </div>
			<div class="slides">
				<section>
					<h2>Bringing GraphQL to the Enterprise:</h2>
					<h4>When IBM Met Apollo</h4>
				</section>
				
				<section>
					<h3>About me:</h3>

					<ul>
						<li>Born and raised in Fort Collins, Colorado</li>
						<li>Colorado State University (2013)</li>
						<li>Sold Insurance (2013 - 2016)</li>
						<li>Galvanize (2016)</li>
						<li>IBM (2017)</li>
					</ul>
				</section>

				<section>
						<h3>About Jason:</h3>
	
						<ul>
							<li>Senior developer / front-end architect  at IBM</li>
							<li>Former workaholic / current work-life balance advocate</li>
							<li><em>Obsessed</em> with processes &amp; efficiency</li>
							<li>World's oldest young man</li>
						</ul>
					</section>

				<section>
					<h3>GraphQL is awesome.</h3>
					<h4 class="fragment">Why?</h4>
				</section>

				<section>
					<h2>Because Front-End Development<br>Is <strong>Hard</strong></h2>
				</section>

				<section>
					<h4>Why is front-end development hard?</h4>
					<ul>
						<li class="fragment">More and more app logic is living in the front-end</li>
						<li class="fragment">The front-end is creeping further into the back-end</li>
						<li class="fragment">Our apps have to be <em>fast</em>...</li>
						<li class="fragment">...even on slow and unstable connections</li>
					</ul>
				</section>

				<section>
					<h3>It‚Äôs harder across teams:</h3>
					<ul>
						<li class="fragment">FEDs are dependent on back-end teams</li>
						<li class="fragment">APIs have to exist before UI work can start</li>
						<li class="fragment">If docs are missing or out of date... </li>
						<li class="fragment">...our ‚Äúdocs‚Äù are asking Steve on Slack</li>
					</ul>
				</section>

				<section>
					<h2>Back-end teams <strong>burn</strong> tons of hours supporting FEDs</h2>
					<aside class="notes">
						Back-end teams have to create aggregate API endpoints, deal with the
						pressure of being a bottleneck for other teams, and support other
						developers who don‚Äôt have what they need to get started. All of this
						happens <em>instead</em> of completing their tasks.
					</aside>
				</section>

				<section>
					<h2>Front-end teams <strong>burn</strong> tons of hours getting started</h2>
					<aside class="notes">
						Take a poll in the room: by a show of hands, how many people have wasted
						more than 8 hours trying to get a new UI up and running? Hunting down a 
						way to load data needed to build a UI? On the phone, post a scream emoji.
					</aside>
				</section>

				<section>
					<h3>And if a server goes down...</h3><img src="lib/images/server-down.gif" alt="Simpsons taking the system down.">
				</section>
				<section>
					<h3>...we wait.</h3><img src="lib/images/waiting.gif" alt="Cookie Monster waiting.">
				</section>
				<section>
					<h2>It can be rough on our <em>users</em>, too.</h2>
				</section>
				<section>
					<blockquote cite="https://www.doubleclickbygoogle.com/articles/mobile-speed-matters/">
						<p>
							"53% of visits are abandoned if a mobile site takes more than three
							seconds to load"
						</p>
						<span>- DoubleClick</span>
					</blockquote>
				</section>
				<section>
					<h2>We can do <em>better</em></h2>
				</section>
				<section>
					<h2>What if we could...</h2>
					<ul>
						<li class="fragment">find all our data in a single place?</li>
						<li class="fragment">test data queries in the browser?</li>
						<li class="fragment">create custom queries with only data we need?</li>
						<li class="fragment">work in parallel with back-end teams?</li>
						<li class="fragment">develop even if the server is down?</li>
						<li class="fragment">show explorable UIs before data is loaded?</li>
						<li class="fragment">render data as it loads instead of all at once?</li>
					</ul>
				</section>
				<section>
					<p><small>(Pause for dramatic effect.)</small></p>
				</section>
				<section>
					<h2>üéâ We can! üéâ</h2>
					<h4>...and <em>GraphQL</em> + <em>React</em> make it easy</h4>
				</section>
				<section>
					<h4>Interactive Online <em>Documentation</em></h4><img class="no-margin" src="lib/images/graphql-playground.png" alt="GraphQL Playground.">
					<p class="no-margin">Guaranteed to be up-to-date!</p>
				</section>
				<section>
					<h4><em>Test Queries</em> in the Browser</h4><img class="no-margin" src="lib/images/full-query.png" alt="GraphQL query and result.">
					<p class="no-margin">This is copy-pasteable into your app.</p>
				</section>
				<section>
					<h4>Load <em>Only</em> Data We Need</h4><img class="no-margin" src="lib/images/query-test.png" alt="GraphQL Playground query with only a few fields.">
					<p class="no-margin">No wasted data transfer.</p>
				</section>
				<section>
					<h4>Work <em>Offline</em></h4><img class="no-margin" src="lib/images/mock-data.png" alt="GraphQL query using mock data.">
					<p class="no-margin">Get realistic, variable mock data.</p>
				</section>
				<section>
					<h2>Adding data to the UI is a breeze üëå</h2>
				</section>
				<section><img class="no-margin no-border" src="lib/images/react-with-data.png" alt="React component using GraphQL query.">
				</section>
				<section>
					<h4><em>Loading states</em> are basically free</h4><img class="no-margin no-border" src="lib/images/loading-pattern.png" alt="Loading and error properties.">
				</section>
				<section>
					<h4><em>Skeleton</em> components üíÄ are even better</h4><img class="no-margin no-border" src="lib/images/skeleton-pattern.png" alt="Loading class for skeleton components.">
				</section>
				<section>
					<h4>Skeleton components let us render an explorable UI <em>before</em> data is loaded</h4>
					<p class="codepen" data-height="396" data-theme-id="0" data-slug-hash="NabRVb" data-default-tab="result" data-user="jlengstorf" data-embed-version="2" data-pen-title="Skeleton Loading Pattern Example" style="min-height: 350px;">See the Pen <a href="https://codepen.io/jlengstorf/pen/JMVYoa/">Skeleton Loading Pattern Example for Links</a> by Jason Lengstorf (<a href="https://codepen.io/jlengstorf">@jlengstorf</a>) on <a href="https://codepen.io">CodePen</a>.</p>
					<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
				</section>
				<section>
					<h4>We can also show data <em>as it arrives</em></h4><img class="no-margin no-border" src="lib/images/deferred.png" alt="Deferred data loading.">
				</section>
				<section>
					<h2>Proof of Concept:</h2>
					<h4>IBM Cloud Account Usage Dashboard</h4>

					<aside class="notes">
						<ul>
							<li>
								So with all of these exciting benefits in mind, we wanted to put them
								into practice by re-making a page on IBM Cloud with React and Apollo's
								GraphQL client.
							</li>
							<li>
								This way we would have something tangible to show the higher-ups and
								actually get some buy-in to put GraphQL into production at IBM.
							</li>
						</ul> 
					</aside>
				</section>
				<section>
					<video src="lib/videos/2017-06-08-comparison_first-load.mp4" controls></video>

					<aside class="notes">
						<ul>
							<li>
								And before I show you this video, let me set the scene.
							</li>
							<li>
								The page we decided to rebuild was the usage dashboard. This is the
								page that users visit to see the cost breakdown for their monthly
								bill from IBM Cloud.
							</li>
							<li>
								This page was built in Dojo, at breakneck speed back when IBM was 
								trying to get Bluemix off the ground.
							</li>
							<li>
								And finally, the account we're using is a test account, filled
								with a bunch of random services and data, so in terms of performance,
								it's a true worst-case scenario.
							</li>
						</ul> 
					</aside>
				</section>
				<section>
					<video src="lib/videos/2017-06-08-comparison_switch-account.mp4" controls></video>
				</section>

				<!-- GrAMPS -->

				<section>
					<h3>We wanted to start using it in production <em>immediately</em></h3>
					<aside class="notes">
						We were so excited with the results of our proof of concept that we wanted
						to rip out our entire middle tier and replace it with GraphQL.
						
					</aside>
				</section>
				<section><img src="lib/images/nope.gif" alt="nope">
					<h3 class="no-margin">Not everyone was on board</h3>
					<aside class="notes">
						Other teams immediately started voicing concerns, and a number of really
						good questions were raised. Which is a good thing, because we were only
						thinking about the end ‚Äî not the path we‚Äôd have to take to get there.
						
					</aside>
				</section>
				<section>
					<h4>Before we get into the details,<br>let me set the scene&hellip;</h4>
					<aside class="notes">
						Before I bring up the questions that were asked, let me give you some
						insight into the way things are structured on our product.
						
					</aside>
				</section>
				<section>
					<h3>How <em>IBM Cloud</em> is built:</h3>
					<ul>
						<li class="fragment">Node ¬µ-service architecture</li>
						<li class="fragment">30+ ¬µ-service teams</li>
						<li class="fragment">Each ¬µ-service (‚Äúplugin‚Äù) is a separate codebase</li>
						<li class="fragment">Teams control their own workflow</li>
					</ul>
					<aside class="notes">
						There are a couple of shared NPM modules for things like session management
						and authorization, but for the most part, teams are able to control their 
						own workflow. But...
						
					</aside>
				</section>
				<section>
					<h3>This has its <strong>downsides</strong>:</h3>
					<ul>
						<li class="fragment">Things can change in 30+ directions at any given time</li>
						<li class="fragment">Front-ends need data from multiple ¬µ-services</li>
						<li class="fragment">Internal documentation &amp; architecture is inconsistent</li>
						<li class="fragment">Code can be wildly inconsistent between ¬µ-services</li>
					</ul>
					<aside class="notes">
						<ul>
							<li>
									Things can change in 30+ directions at any given time, and more often
									then not, a change will happen that not everyone is prepared for, meaning
									downtime, late night phone calls, and whatever else.
							</li>
							<li>
									Building a new UI from scratch means you have to burn a lot of time tracking
									down where you're going to get your data from.
							</li>
							<li>
									And because internal documentation is inconsistent, when you do finally
									find what you're looking for, there's a good chance it's out of date,
									incomplete, and in some cases, both.
							</li>
							<li>
									And because code can be so wildly inconsistent between ¬µ-services, if you 
									take a look at the network tab while you're browsing IBM Cloud, there's
									a good change you'll load jQuery, Dojo, Polymer, Angular, React, Vue, and
									whatever framework is popular 6 months from now.
							</li>
						</ul>
					</aside>
				</section>
				<section>
					<h3 style="width: 110%; margin-left: -5%;">GraphQL has <em>solutions</em>:</h3>
					<ul>
						<li class="fragment">Changes are centralized in the GraphQL ¬µ-service</li>
						<li class="fragment">Data access happens through a single endpoint</li>
						<li class="fragment">Documentation is centralized and consistent</li>
						<li class="fragment">Cleaner separation between data and presentation</li>
					</ul>
					<aside class="notes">
						<ul>
							<li>
								Changes get centralized. If a back-end team is going to make a breaking change,
								they only have to let GraphQL know, and it can then deprecate the field, add notes,
								link to upgrade path docs, etc. Bottom line is that everyone is prepared.
							</li>
							<li>
								Being able to cut down of the amount of HTTP requests you send can be a huge boon
								to performance. 
							</li>
							<li>
								As I mentioned before, documentation is automatically generated by the schema,
								so any changes are centralized and consistent. And even if they're not as great
								as we might hope, you can still play around with those queries right in the
								browser.
							</li>
							<li>
								By abstracting our data fetching into a middle tier, we're able to get a clearer
								picture as to where problems actually occur.
							</li>
						</ul>
					</aside>
				</section>
				<section>
					<h3 style="width: 110%; margin-left: -5%;">But there are <strong>complications</strong>:</h3>
					<ul>
						<li class="fragment">Who ‚Äúowns‚Äù the GraphQL ¬µ-service?</li>
						<li class="fragment">How can teams make independent changes?</li>
						<li class="fragment">Can one bad commit take down the whole service?</li>
						<li class="fragment">Doesn‚Äôt an extra layer make it harder to trace errors?</li>
					</ul>

					<aside class="notes">
						<ul>
							<li>
								Does every team need to hand over control of their data to this one service?
							</li>
							<li>
								If a back-end team needs to update their GraphQL schema, do they have to submit
								a pull request, and just be at the whim of this gatekeeper?
							</li>
							<li>
								If this service, goes down, would that take down every single team along with
								it?
							</li>
						</ul>
					</aside>
				</section>
				<section>
					<h3>We wanted the <em>benefits</em> of GraphQL&hellip;<span class="fragment"> but could we afford the trade-offs?</span></h3>
				</section>
				<section>
					<h2>We needed <em>answers</em></h2>
				</section>
				<section>
					<h3 class="u--align-left">Can we...</h3>
					<ol>
						<li class="fragment">Centralize data, but let teams keep control?</li>
						<li class="fragment">Design an approach that <em>improves</em> error handling?</li>
						<li class="fragment">Make it so easy teams <em>want</em> to switch?</li>
						<li class="fragment">Build a service that can handle IBM‚Äôs scale?</li>
					</ol>
					<aside class="notes">
						<ul>
							<li>
								We're currently running at about half a dozen data centers around the world,
								so could this be robust enough to handle our level of traffic?
							</li>
						</ul>
					</aside>
				</section>
				<section>
					<h4 class="no-margin">Challenge #1:</h4>
					<h2 class="no-margin"><em>Centralize</em> Data, but <em>Decentralize</em> Control</h2>
				</section>
				<section>
					<h3>The ideal <em>solution</em>:</h3>
					<p><span>Each team maintains their own GraphQL schema...</span><br><span class="fragment"> but that schema is aggregated by a central ¬µ-service.</span></p>
				</section>
				<section>
					<h3 style="width: 110%;max-width: 110%; margin-left: -5%;">If this was going to work, we needed a <em>standardized format</em> 
						for sharing schemas.
						
					</h3>
				</section>
				<section>
					<h2>We call these<br><em>Data Sources</em></h2>
				</section>
				<section>
					<img class="no-border" src="lib/images/gramps-data-source-1.svg" alt="GrAMPS data source, part 1">
				</section>
				<section>
					<img class="no-border" src="lib/images/gramps-data-source-2.svg" alt="GrAMPS data source, part 2">
				</section>
				<section>
					<img class="no-border" src="lib/images/gramps-data-source-3.svg" alt="GrAMPS data source, part 3">
				</section>
				<section>
					<img class="no-border" src="lib/images/gramps-data-source-4.svg" alt="GrAMPS data source, part 4">
				</section>
				<section>
					<img class="no-border" src="lib/images/gramps-data-source-5.svg" alt="GrAMPS data source, part 5">
				</section>
				<section>
					<h3>Each data source is an <em>independent</em> GitHub repo, which means:</h3>
					<ul class="align-center">
						<li class="fragment">‚úÖ No bottlenecks<br><small>Each team commits and deploys code independently.</small></li>
						<li class="fragment">‚úÖ No loss of control<br><small>Each team owns their data source.</small></li>
						<li class="fragment">‚úÖ No accidental borking<br><small>Each team‚Äôs code has individual test suites.</small></li>
					</ul>
				</section>
				<section>
					<h3>How do we <em>combine</em> the data sources?</h3>
					<aside class="notes">
						<ul>
							<li>The GraphQL ¬µ-service core is an empty schema</li>
							<li>Each data source is an npm package, which is added as a dependency</li>
							<li>
								Express middleware composes the data sources into a single set of 
								arguments for use with the Apollo Express server
								
							</li>
						</ul>
					</aside>
				</section>
				<section><img class="no-border" src="lib/images/gramps-all-together-1.svg" alt="GrAMPS architecture, part 1">
				</section>
				<section><img class="no-border" src="lib/images/gramps-all-together-2.svg" alt="GrAMPS architecture, part 2">
				</section>
				<section><img class="no-border" src="lib/images/gramps-all-together-3.svg" alt="GrAMPS architecture, part 3">
				</section>
				<section><img class="no-border" src="lib/images/gramps-all-together-4.svg" alt="GrAMPS architecture, part 4">
				</section>
				<section>
					<h2><em>Implementation</em> is easy enough to fit the code on a slide</h2>
				</section>
				<section>
					<h4>Let‚Äôs <em>Upgrade</em> this GraphQL Server</h4>
					<pre style="font-size: 18px;"><code class="js">
import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';

import mySchema from './schema';
import myDataAccess from './data';

const app = new Express();
app.use(bodyParser.json());
app.use('/graphql',
	graphqlExpress({
		schema: mySchema,
		context: myDataAccess,
	}),
);
					</code></pre>
				</section>
				<section>
					<h4>Step 1: Import the <em>Middleware</em></h4>
					<pre style="font-size: 18px;"><code class="diff"> 
import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';
+ import { grampsExpress } from '@gramps/gramps-express';

import mySchema from './schema';
import myDataAccess from './data';

const app = new Express();
app.use(bodyParser.json());
app.use('/graphql',
	graphqlExpress({
		schema: mySchema,
		context: myDataAccess,
	}),
);
					</code></pre>
				</section>
				<section>
					<h4>Step 2: Import the <em>Data Sources</em></h4>
					<pre style="font-size: 18px;"><code class="diff">
import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';
import { grampsExpress } from '@gramps/gramps-express';

- import mySchema from './schema';
- import myDataAccess from './data';
+ import schemaOne from '@gramps/data-source-one';
+ import schemaTwo from '@gramps/data-source-two';

const app = new Express();
app.use(bodyParser.json());
app.use('/graphql',
	graphqlExpress({
		schema: mySchema,
		context: myDataAccess,
	}),
);
					</code></pre>
				</section>
				<section>
					<h4>Step 3: <em>Combine</em> the Data Sources</h4>
					<pre style="font-size: 18px;"><code class="diff">
import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';
import { grampsExpress } from '@gramps/gramps-express';

import schemaOne from '@gramps/data-source-one';
import schemaTwo from '@gramps/data-source-two';

const app = new Express();
app.use(bodyParser.json());
+ app.use(grampsExpress({ dataSources: [ schemaOne, schemaTwo ] }));
app.use('/graphql',
	graphqlExpress({
		schema: mySchema,
		context: myDataAccess,
	}),
);
					</code></pre>
				</section>
				<section>
					<h4>Step 4: Use the New <em>Schema</em> and <em>Context</em></h4>
					<pre style="font-size: 18px;"><code class="diff">
import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';
import { grampsExpress } from '@gramps/gramps-express';

import schemaOne from '@gramps/data-source-one';
import schemaTwo from '@gramps/data-source-two';

const app = new Express();
app.use(bodyParser.json());
app.use(grampsExpress({ dataSources: [ schemaOne, schemaTwo ] }));
app.use('/graphql',
+   graphqlExpress(req => ({
+     schema: req.gramps.schema,
+     context: req.gramps.context,
+   })),
);
					</code></pre>
				</section>
				<section>
					<h4 class="no-margin">Challenge #2:</h4>
					<h2 class="no-margin"><em>Improve</em> Error Handling</h2>
				</section>
				<section>
					<h3 style="width: 110%;margin-left: -5%;">What Makes an Error <em>Helpful</em>?</h3>
					<ul>
						<li class="fragment">Clear description of what went wrong</li>
						<li class="fragment">Clarity about where the error occurred
							<ul>
								<li style="font-size: 90%;">GraphQL errors vs. underlying data access issues</li>
							</ul>
						</li>
						<li class="fragment">Information to help with tracing bugs</li>
						<li class="fragment">Unique IDs shared on the client and server side</li>
					</ul>
				</section>
				<section>
					<h4><em>Client-Side</em> Errors in Development</h4><img class="no-margin" src="lib/images/client-side-error.png" alt="GrAMPS client-side error">
				</section>
				<section>
					<h4>In production, we <strong>can‚Äôt show some data</strong></h4>
					<ul>
						<li class="fragment">Docs link may be behind our firewall</li>
						<li class="fragment">Target endpoint may not be public</li>
					</ul>
				</section>
				<section>
					<h4>Client-Side Errors in <em>Production</em></h4><img class="no-margin" src="lib/images/client-side-error-production.png" alt="GrAMPS client-side error in production">
					<p class="no-margin"><small><code>docsLink</code> and <code>targetEndpoint</code> are removed in production.
							</small></p>
				</section>
				<section>
					<h4>Client and server errors share a <em>GUID</em></h4>
					<pre><code class="sh">
Error: Could not load the given xkcd comic (178460c1-c8d7-42c2-ba0e-f617afb5d3fd)
Description: Could not load the given xkcd comic
Error Code: XKCDModel_Error
GraphQL Model: XKCDModel
Target Endpoint: https://xkcd.com/2000/info.0.json
Documentation: https://ibm.biz/gramps-data-source-tutorial
Data: {
	"id": "2000"
}
					</code></pre>
					<p class="no-margin"><small>Using the GUID, we can find the <code>docsLink</code> and 
							<code>targetEndpoint</code> in the server logs.
							</small></p>
				</section>
				<section>
					<h3 class="u--align-left">This Means...</h3>
					<ul>
						<li class="fragment">Errors are normalized across all data sources</li>
						<li class="fragment">Support tickets can directly reference details in logs</li>
						<li class="fragment">Errors are clear and come with documentation</li>
						<li class="fragment">The source of a given error is immediately clear</li>
					</ul>
				</section>
				<section>
					<h4>Implementation Is <em>Optional</em> and <em>Easy</em></h4>
					<pre style="font-size: 18px;"><code class="diff">
import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';
import { grampsExpress } from '@gramps/gramps-express';

import schemaOne from '@gramps/data-source-one';
import schemaTwo from '@gramps/data-source-two';

const app = new Express();
app.use(bodyParser.json());
app.use(grampsExpress({ dataSources: [ schemaOne, schemaTwo ] }));
app.use('/graphql',
	graphqlExpress(req => ({
		schema: req.gramps.schema,
		context: req.gramps.context,
+     formatError: req.gramps.formatError,
	})),
);
					</code></pre>
				</section>
				<section>
					<h4 class="no-margin">Challenge #3:</h4>
					<h2 class="no-margin">Make Development So <em>Easy</em> Teams Want to Use It</h2>
				</section>
				<section>
					<h3>If we wanted teams to <em>start using GraphQL</em>, we needed it to be 
						<em>dead simple</em> to get started
						
					</h3>
				</section>
				<section>
					<h3>We created a data source <em>starter kit</em>:</h3>
					<ul>
						<li class="fragment">Strong starting point for new data sources</li>
						<li class="fragment">Step-by-step tutorial for building a new data source</li>
						<li class="fragment">Test coverage starts at üíØ</li>
						<li class="fragment">Pre-configured for Travis CI and Code Climate</li>
					</ul>
					<p><small class="fragment"><a href="https://github.com/gramps-graphql/data-source-base">
								github.com/gramps-graphql/data-source-base
								</a></small></p>
				</section>
				<section>
					<h4>We built a <em>CLI</em> to make development easier</h4>
					<pre><code class="sh">
$ gramps --live

============================================================
		GrAMPS is running in live mode on port 8080

		GraphiQL: http://localhost:8080/graphiql
============================================================
					</code></pre>
				</section>
				<section>
					<h3>But there was a <strong>snag</strong>:</h3>
					<p class="fragment">‚ÄúHow do we run a local instance of the GraphQL<br>¬µ-service if the data 
						source we‚Äôre developing is already installed? Won‚Äôt they collide?‚Äù
						
					</p>
				</section>
				<section>
					<h3>The solution?</h3>
					<h2>Allow local<br>data sources<br>to <em>override</em></h2>
					<p><code class="sh">gramps --data-source-dir ./</code></p>
					<aside class="notes">
						We built a CLI to make development easier, then added checks for
						data source name collisions, giving local data sources precedence.
						
					</aside>
				</section>
				<section>
					<h4>But add a <em>warning</em></h4><img class="no-margin" src="lib/images/local-data-source-warnings-pt1.png" alt="GrAMPS warnings for local data sources">
					<p class="no-margin"><small>Clarified text and updated links are coming (<a href="https://github.com/gramps-graphql/gramps-express/issues/36">#36</a>)</small></p>
				</section>
				<section>
					<h4>Actually, add <em>two</em> warnings</h4><img class="no-margin" src="lib/images/local-data-source-warnings-pt2.png" alt="GrAMPS warnings for local data sources">
					<p class="no-margin"><small>Clarified text and updated links are coming (<a href="https://github.com/gramps-graphql/gramps-express/issues/36">#36</a>)</small></p>
				</section>
				<section>
					<h4 class="no-margin">Challenge #4:</h4>
					<h2 class="no-margin">Build for<br><em>Global</em> Scale</h2>
				</section>
				<section>
					<h3>We didn‚Äôt have to do much</h3>
					<p class="fragment">It turns out Apollo‚Äôs Express server just works.</p>
				</section>
				<section><img src="lib/images/pleasant-surprise.gif" alt="pleasant surprise from The Office">
					<h3 class="no-margin">Which is pretty <em>great</em></h3>
				</section>
				<section>
					<h3>We <em>started</em> working on the GraphQL 
						<span style="text-transform: none;">¬µ</span>-service in <em>May</em>
						
					</h3>
				</section>
				<section>
					<h3>It hit <em>production</em> in <em>July</em></h3>
				</section>
				<section>
					<h3>After the dust settled,<br>we realized <em>two things</em></h3>
				</section>
				<section>
					<h2>#1</h2>
					<p>
						‚ÄúIf everyone wrote their data sources using this format, the 
						dev community could share GraphQL data sources as easily as we share 
						npm packages.‚Äù
						
					</p>
				</section>
				<section>
					<h2>#2</h2>
					<p>‚ÄúThis might be useful to other people.‚Äù</p>
				</section>
				<section>
					<h2>So we<br>released it under the <em>MIT license</em></h2>
					<h2>üéâ</h2>
				</section>
				<section><img class="no-border" src="lib/images/GrAMPS-logo.svg" alt="GrAMPS: GraphQL Apollo Microservice Pattern Server" style="max-width: 400px;">
					<h1 class="no-margin">GrAMPS</h1>
					<p><strong>Gr</strong>aphQL 
						<strong>A</strong>pollo 
						<strong>M</strong>icroservice 
						<strong>P</strong>attern 
						<strong>S</strong>erver
						<small>
							<a href="https://github.com/gramps-graphql/gramps-express">github.com/gramps-graphql/gramps-express</a> &nbsp; ¬∑ &nbsp; <a href="https://www.npmjs.com/org/gramps">npmjs.com/org/gramps</a>
						</small>
					</p>
				</section>
				<section>
					<h2>Thanks!</h2>
				</section>
				<section class="u--align-left resourcetext">
					<h4>Resources</h4>
					<ol>
						<li><a href="https://github.com/gramps-graphql">GrAMPS on GitHub</a></li>
						<li><a href="https://github.com/gramps-graphql/gramps-express">GrAMPS Express Middleware</a></li>
						<li><a href="https://gramps-graphql.github.io/gramps-express/">GrAMPS Documentation</a></li>
						<li><a href="https://dev-blog.apollodata.com/how-to-build-graphql-servers-87587591ded5">How to Build GraphQL Servers</a></li>
						<li><a href="https://github.com/gramps-graphql/data-source-base">GrAMPS Data Source Starter Kit</a></li>
						<li><a href="https://ibm.biz/gramps-data-source-tutorial">GrAMPS Data Source Tutorial</a></li>
						<li><a href="https://www.npmjs.com/org/gramps">
								GrAMPS on npm
								</a></li>
					</ol>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
