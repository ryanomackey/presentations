<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/carbon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/github.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="header">
				<div class="ibm">
					<svg class="ibm__cloud-icon" xmlns="http://www.w3.org/2000/svg" id="Layer_1" data-name="Layer 1" viewBox="0 0 275.76529 243.9836"><defs><style>.cls-1{fill:url(#linear-gradient)}.cls-2{fill:url(#linear-gradient-2)}.cls-3{fill:url(#linear-gradient-3)}</style><linearGradient id="linear-gradient" x1="4979.474" y1="10122.533" x2="5087.703" y2="10103.45" gradientTransform="scale(-1 1) rotate(-45 -9605.065 11330.987)" gradientUnits="userSpaceOnUse"><stop stop-color="#fff" offset=".2" stop-opacity="0"/><stop stop-color="#fff" offset=".287" stop-opacity=".03"/><stop stop-color="#fff" offset=".501" stop-opacity=".2"/><stop stop-color="#fff" offset=".793" stop-opacity=".742"/><stop stop-color="#fff" offset="1"/></linearGradient><linearGradient id="linear-gradient-2" x1="-.357" y1="51.748" x2="63.087" y2="88.378" gradientTransform="matrix(1 0 0 -1 -5.791 224.135)" gradientUnits="userSpaceOnUse"><stop stop-color="#fff" offset=".08"/><stop stop-color="#fff" offset=".753" stop-opacity=".07"/><stop stop-color="#fff" offset=".875" stop-opacity="0"/></linearGradient><linearGradient id="linear-gradient-3" x1="144.665" y1="44.837" x2="241.172" y2="125.816" gradientTransform="matrix(1 0 0 -1 -5.791 224.135)" gradientUnits="userSpaceOnUse"><stop stop-color="#fff" offset=".138" stop-opacity="0"/><stop stop-color="#fff" offset=".32" stop-opacity=".07"/><stop stop-color="#fff" offset=".847" stop-opacity=".764"/><stop stop-color="#fff" offset=".947"/></linearGradient></defs><title>cloud-svg-mark</title><path fill="#fff" d="M36.697 97.367a5.195 5.195 0 0 1-2.604-.7L9.19 82.288a5.217 5.217 0 1 1 5.217-9.037L39.31 87.63a5.218 5.218 0 0 1-2.613 9.737zM79.293 54.781a5.215 5.215 0 0 1-4.524-2.61L60.39 27.268a5.218 5.218 0 0 1 9.037-5.218l14.38 24.905a5.219 5.219 0 0 1-4.514 7.827zM137.46 39.192a5.217 5.217 0 0 1-5.217-5.217V5.217a5.218 5.218 0 0 1 10.435 0v28.758a5.217 5.217 0 0 1-5.217 5.217zM195.63 54.781a5.219 5.219 0 0 1-4.514-7.827l14.379-24.905a5.218 5.218 0 0 1 9.037 5.218l-14.379 24.905a5.216 5.216 0 0 1-4.523 2.61zM238.225 97.367a5.218 5.218 0 0 1-2.613-9.737l24.904-14.379a5.217 5.217 0 1 1 5.217 9.037L240.83 96.667a5.195 5.195 0 0 1-2.604.7z"/><path fill="#fff" class="cls-1" d="M71.232 216.548A93.66 93.66 0 0 1 203.687 84.09a95.03 95.03 0 0 1 7.451 8.388 93.907 93.907 0 0 1 4.55 6.303l-8.709 5.748a83.29 83.29 0 0 0-4.04-5.597 84.494 84.494 0 0 0-6.628-7.46 83.226 83.226 0 0 0-117.698 117.7z"/><path fill="#fff" d="M204.23 243.984c-.183 0-.364 0-.548-.002h-143.6a60.495 60.495 0 0 1-60.08-60.944l10.435.078a50.058 50.058 0 0 0 49.685 50.43h143.6c.152.002.31.003.462.003a61.117 61.117 0 0 0 45.582-101.861l7.778-6.957a71.552 71.552 0 0 1-53.315 119.253z"/><path fill="#fff" class="cls-2" d="M10.437 183.116l-10.435-.078a60.43 60.43 0 0 1 50.409-59.207l1.742 10.29a50.006 50.006 0 0 0-41.716 48.995z"/><path fill="#fff" class="cls-3" d="M143.102 171.978l-10.435-.079a71.55 71.55 0 0 1 124.877-47.169l-7.778 6.957a61.115 61.115 0 0 0-106.664 40.29z"/></svg>
					<div>
						<span class="ibm__brand">IBM</span> <span class="ibm__product">Cloud</span>
					</div>
				</div>
			</div>

			<div class="slides">
				<section>
					<h2>Bringing GraphQL to the Enterprise</h2>
					<h3><strong>When IBM Met Apollo</strong></h3>
				</section>
				
				<section>
					<h3>About me:</h3>

					<ul>
						<li class="fragment">From Fort Collins, Colorado</li>
						<li class="fragment">Political Science @ CSU</li>
						<li class="fragment">IBM Cloud in Austin, TX</li>
						<li class="fragment">‚ùÑÔ∏è => üî•</li>
					</ul>

					<aside class="notes">
						<ul>
							<li>
								Before I get into my talk, let me tell you a little bit about myself. My name is
								Ryan Mackey, and I'm originally from Fort Collins, Colorado.
							</li>
					
							<li>
								While I was there, I got my degree in Political Science at Colorado State, and if
								you‚Äôve been keeping up with the news, it should be pretty obvious why I got in
								to web development instead.
							</li>
					
							<li>
								Now, I'm a Front-End Developer at IBM working on their cloud platform in Austin,
								Texas, so I've basically gone from not leaving my apartment the entire winter,
								to not leaving my apartment the entire summer.
							</li>
						</ul>
					</aside>
				</section>

				<section>
					<svg viewBox="0,0,816,240">
						<path class="apollo" d="M169.68,161.48h-22l-25.27-71.7L108.22,129h21.84l6,17.07H102.89l-5.74,15.43h-22l35.1-91.1h24.31Zm392.25,0V144.41H523.41v-74H503.88v91.1Zm112.57,0V144.41H636v-74H616.44v91.1ZM395.71,86.71A29.29,29.29,0,1,0,425,116a29.32,29.32,0,0,0-29.29-29.29m0-17.83A47.12,47.12,0,1,1,348.6,116a47.12,47.12,0,0,1,47.12-47.12ZM764.28,86.71A29.29,29.29,0,1,0,793.57,116a29.32,29.32,0,0,0-29.29-29.29m0-17.83A47.12,47.12,0,1,1,717.16,116a47.12,47.12,0,0,1,47.12-47.12Zm-466,31.38c0,16.19-13.12,29.87-29.32,29.87H245.9v31.35H226.5V70.38H269C285.17,70.38,298.29,84.06,298.29,100.25Zm-17.83,0c0-6.33-5.15-12-11.49-12H245.9V112.3H269C275.31,112.3,280.47,106.59,280.47,100.25Zm-70.71,88.87a5,5,0,0,0-4.09,2.12s-4.37,5-6.73,7.35a108.71,108.71,0,1,1-8.49-161.28A12.25,12.25,0,1,0,197.3,30a118.67,118.67,0,1,0,16,167.71,5,5,0,0,0-3.55-8.56Z" transform="translate(-3.46 -3.12)"></path>
					</svg>

					<aside class="notes">
						<ul>
							<li>
								So, I start at IBM about a year ago, and I'm immediately paired up with a senior
								developer named, Jason Lengstorf.
							</li>
					
							<li>
								And at the time, Jason was really excited about GraphQL. Specifically, he was really
								excited about a library for GraphQL called Apollo.
							</li>
					
							<li>
								And after I played around with it for a bit, I got really excited about it as well.
							</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>No overfetching</h3>
<pre style="font-size: 18px;" class="graphql"><code data-trim> 
query { 
  Users {
    id
    username
  }
}
</code></pre>

<pre style="font-size: 18px;" class="json"><code data-trim> 
{
  "Users": [
    {
      "id": 1,
      "username": "steve"
    },
    {
      "id": 2,
      "username": "steve2"
    }
  ]
}
</code></pre>

					<aside class="notes">
						<ul>
							<li>
								If you're new to GraphQL, this is where it all starts. You write what are called
								queries, and describe the data that you want; nothing more, nothing less.
							</li>
							<li>
								And on top of that, you get back that data in the exact same shape that you described.
							</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>In-browser IDEs</h3>
					<video autoplay loop>
						<source src="lib/videos/graphiql.mp4#t=23,39" />
					</video>

					<aside class="notes">
						<ul>
							<li>
								Another great thing from a UI standpoint is the developer tools.
							</li>
							<li>
								Using the type definitions (or schema) from your GraphQL server, these tools can
								generate instant documentation and let you test queries and mutations right from
								the browser.
							</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>The entire request cycle is handled for you</h3>

<pre style="font-size: 18px;" class="javascript"><code data-trim> 
const UsersQuery = `query { Users { username } }`;

const UsersList = ({ data: { Users }, loading, error }) => {
  if (loading) {
    return <p>Loading...</p>
  }

  if (error) {
    return <p>Error!</p>
  }

  return (
    <ul>
      {Users.map(user => <li>{user.username}</li>)}
    </ul>
  );
}

export default graphql(UsersQuery)(UsersList);
</code></pre>

					<aside class="notes">
						<ul>
							<li>
								With Apollo, for every React component that you wrap with a query, in addition to
								the data, you get the loading state, as well as any errors, all for free.
							</li>
							<li>
								So as a UI developer, this means you can focus all of your attenion on presentation
								and user experience.
							</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>Zero-config Caching</h3>

					<ol>
						<li>
							The query is loaded from the Apollo <strong>client-side data store</strong>, 
							or the server if the data is not in the store.
						</li>
						<li>
							Our component <strong>subscribes to the store</strong>, so that it is updated
							if the data changes as the result of a mutation or some other response from 
							the server.
						</li>
					</ol>

					<aside class="notes">
						<ul>
							<li>Two things happen when a Apollo tries to execute a query on the client side:</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>Proof of Concept:</h2>
					<h4>IBM Cloud Account Usage Dashboard</h4>

					<aside class="notes">
						<ul>
							<li>
								In order to get some buy-in to start putting this into production, we had to start
								with a proof of concept.
							</li>
						</ul>
					</aside>
				</section>
				<section>
					<video src="lib/videos/2017-06-08-comparison_first-load.mp4" controls></video>

					<aside class="notes">
						<ul>
							<li>
								And before I show you this video, let me set the scene.
							</li>
							<li>
								The page we decided to rebuild was the usage dashboard. This is the page that users
								visit to see the cost breakdown for their monthly bill from IBM Cloud.
							</li>
							<li>
								This page was built in Dojo, at breakneck speed back when IBM was trying to get Bluemix
								off the ground.
							</li>
							<li>
								And finally, the account we're using is a test account, filled with a bunch of random
								services and data, so in terms of performance, it's a true worst-case scenario.
							</li>
						</ul>
					</aside>
				</section>
				<section>
					<video src="lib/videos/2017-06-08-comparison_switch-account.mp4#t=13" controls></video>

					<aside class="notes">
						<ul>
							<li>
								And because of the zero-config caching, users could switch back and forth between
								accounts they had already loaded without having to do any waiting.
							</li>
						</ul>
					</aside>
				</section>

				<!-- GrAMPS -->

				<section>
					<h3>We wanted to start using it in production <em>immediately</em></h3>
					<aside class="notes">
						We were so excited with the results of our proof of concept that we wanted to rip
						out our entire middle tier and replace it with GraphQL.
					</aside>
				</section>
				<section><img src="lib/images/nope.gif" alt="nope">
					<h3 class="no-margin">Not everyone was on board</h3>
					<aside class="notes">
						Other teams immediately started voicing concerns, and a number of really good questions
						were raised. Which is a good thing, because we were only thinking about the end
						‚Äî not the path we‚Äôd have to take to get there.
					</aside>
				</section>
				<section>
					<h4>Before we get into the details,<br>let me set the scene&hellip;</h4>
					<aside class="notes">
						Before I bring up the questions that were asked, let me give you some insight into
						the way things are structured on our product.
					</aside>
				</section>
				<section>
					<h3>How <em>IBM Cloud</em> is built:</h3>
					<ul>
						<li class="fragment">Node ¬µ-service architecture</li>
						<li class="fragment">30+ ¬µ-service teams</li>
						<li class="fragment">Each ¬µ-service (‚Äúplugin‚Äù) is a separate codebase</li>
						<li class="fragment">Teams control their own workflow</li>
					</ul>
					<aside class="notes">
						There are a couple of shared NPM modules for things like session management and authorization,
						but for the most part, teams are able to control their own workflow. But...
					</aside>
				</section>
				<section>
					<h3>This has its <strong>downsides</strong>:</h3>
					<ul>
						<li class="fragment">Things can change in 30+ directions at any given time</li>
						<li class="fragment">Front-ends need data from multiple ¬µ-services</li>
						<li class="fragment">Internal documentation &amp; architecture is inconsistent</li>
						<li class="fragment">Code can be wildly inconsistent between ¬µ-services</li>
					</ul>
					<aside class="notes">
						<ul>
							<li>
								Things can change in 30+ directions at any given time, and more often then not, a
								change will happen that not everyone is prepared for, meaning downtime, late night
								phone calls, and whatever else.
							</li>
							<li>
								Building a new UI from scratch means you have to burn a lot of time tracking down
								where you're going to get your data from.
							</li>
							<li>
								And because internal documentation is inconsistent, when you do finally find what
								you're looking for, there's a good chance it's out of date, incomplete, and in
								some cases, both.
							</li>
							<li>
								And because code can be so wildly inconsistent between ¬µ-services, if you take a
								look at the network tab while you're browsing IBM Cloud, there's a good change
								you'll load jQuery, Dojo, Polymer, Angular, React, Vue, and whatever framework
								is popular 6 months from now.
							</li>
						</ul>
					</aside>
				</section>
				<section>
					<h3 style="width: 110%; margin-left: -5%;">GraphQL has <em>solutions</em>:</h3>
					<ul>
						<li class="fragment">Changes are centralized in the GraphQL ¬µ-service</li>
						<li class="fragment">Data access happens through a single endpoint</li>
						<li class="fragment">Documentation is centralized and consistent</li>
						<li class="fragment">Cleaner separation between data and presentation</li>
					</ul>
					<aside class="notes">
						<ul>
							<li>
								Changes get centralized. If a back-end team is going to make a breaking change,
								they only have to let GraphQL know, and it can then deprecate the field, add notes,
								link to upgrade path docs, etc. Bottom line is that everyone is prepared.
							</li>
							<li>
								Being able to cut down of the amount of HTTP requests you send can be a huge boon
								to performance. 
							</li>
							<li>
								As I mentioned before, documentation is automatically generated by the schema,
								so any changes are centralized and consistent. And even if they're not as great
								as we might hope, you can still play around with those queries right in the
								browser.
							</li>
							<li>
								By abstracting our data fetching into a middle tier, we're able to get a clearer
								picture as to where problems actually occur.
							</li>
						</ul>
					</aside>
				</section>
				<section>
					<h3 style="width: 110%; margin-left: -5%;">But there are <strong>complications</strong>:</h3>
					<ul>
						<li class="fragment">Who ‚Äúowns‚Äù the GraphQL ¬µ-service?</li>
						<li class="fragment">How can teams make independent changes?</li>
						<li class="fragment">Can one bad commit take down the whole service?</li>
						<li class="fragment">Doesn‚Äôt an extra layer make it harder to trace errors?</li>
					</ul>

					<aside class="notes">
						<ul>
							<li>
								Does every team need to hand over control of their data to this one service?
							</li>
							<li>
								If a back-end team needs to update their GraphQL schema, do they have to submit
								a pull request, and just be at the whim of this gatekeeper?
							</li>
							<li>
								If this service, goes down, would that take down every single team along with
								it?
							</li>
						</ul>
					</aside>
				</section>
				<section>
					<h3>We wanted the <em>benefits</em> of GraphQL&hellip;<br><span class="fragment"> but could we afford the trade-offs?</span></h3>
				</section>
				<section>
					<h2>We needed <em>answers</em></h2>
				</section>
				<section>
					<h3 class="u--align-left">Can we...</h3>
					<ol>
						<li class="fragment">Centralize data, but let teams keep control?</li>
						<li class="fragment">Design an approach that <em>improves</em> error handling?</li>
						<li class="fragment">Make it so easy teams <em>want</em> to switch?</li>
						<li class="fragment">Build a service that can handle IBM‚Äôs scale?</li>
					</ol>
					<aside class="notes">
						<ul>
							<li>
								We're currently running at about half a dozen data centers around the world,
								so could this be robust enough to handle our level of traffic?
							</li>
						</ul>
					</aside>
				</section>
				<section>
					<h4 class="no-margin">Challenge #1:</h4>
					<h2 class="no-margin"><em>Centralize</em> Data, but <em>Decentralize</em> Control</h2>
				</section>
				<section>
					<h3>The ideal <em>solution</em>:</h3>
					<p><span>Each team maintains their own GraphQL schema...</span><br><span class="fragment"> but that schema is aggregated by a central ¬µ-service.</span></p>
				</section>
				<section>
					<h3 style="width: 110%;max-width: 110%; margin-left: -5%;">If this was going to work, we needed a <em>standardized format</em> 
						for sharing schemas.
						
					</h3>
				</section>
				<section>
					<h2>We call these<br><em>Data Sources</em></h2>
				</section>
				<section>
					<img class="no-border" src="lib/images/gramps-data-source-1.svg" alt="GrAMPS data source, part 1">
				</section>
				<section>
					<img class="no-border" src="lib/images/gramps-data-source-2.svg" alt="GrAMPS data source, part 2">

					<aside class="notes">
						<ul>
							<li>
								When you're putting together an Apollo server, these are the two things you need.
							</li>
							<li>
								The schema, which we talked about earlier, and resolvers, (or resolve functions),
								which exist to define how all of the fields in the schema get data from any number
								of back-ends.
							</li>
							<li>
								But other than that, you're kind of on your own.
							</li>
						</ul>
					</aside>
				</section>
				<section>
					<img class="no-border" src="lib/images/gramps-data-source-3.svg" alt="GrAMPS data source, part 3">
				</section>
				<section>
					<img class="no-border" src="lib/images/gramps-data-source-4.svg" alt="GrAMPS data source, part 4">

					<aside class="notes">
						<ul>
							<li>
								So with little inspiration from an article written by Jonas Helfer, about
								how to structure GraphQL servers, we added a model and connector to each
								data source.
							</li>
							<li>
								The model, in our case, just being CRUD operations, so things like
								getUserById, deleteUserById, etc.
							</li>
							<li>
								And the connector, which just tells the data source where it's actually
								going to get data from. So for us, it's usually just a base URI, with a
								REST endpoint or two.
							</li>
						</ul>
					</aside>
				</section>
				<section>
					<img class="no-border" src="lib/images/gramps-data-source-5.svg" alt="GrAMPS data source, part 5">

					<aside class="notes">
						<ul>
							<li>
								And so we wrap all of this with a common export, meaning it gets turned
								into a plugin.
							</li>
						</ul>
					</aside>
				</section>
				<section>
					<h3>Each data source is an <em>independent</em> GitHub repo, which means:</h3>
					<ul class="align-center">
						<li class="fragment">‚úÖ No bottlenecks<br><small>Each team commits and deploys code independently.</small></li>
						<li class="fragment">‚úÖ No loss of control<br><small>Each team owns their data source.</small></li>
						<li class="fragment">‚úÖ No accidental borking<br><small>Each team‚Äôs code has individual test suites.</small></li>
					</ul>
				</section>

				<section>
					<h3>How do we <em>combine</em> the data sources?</h3>
				</section>

				<section><img class="no-border" src="lib/images/GrAMPS-logo.svg" alt="GrAMPS: GraphQL Apollo Microservice Pattern Server" style="max-width: 400px;">
					<h1 class="no-margin">GrAMPS</h1>
					<p><strong>Gr</strong>aphQL 
						<strong>A</strong>pollo 
						<strong>M</strong>icroservice 
						<strong>P</strong>attern 
						<strong>S</strong>erver
						<small>
							<a href="https://github.com/gramps-graphql/gramps">github.com/gramps-graphql/gramps</a> &nbsp; ¬∑ &nbsp; <a href="https://www.npmjs.com/org/gramps">npmjs.com/org/gramps</a>
						</small>
					</p>
				</section>

				<section><img class="no-border" src="lib/images/gramps-all-together-1.svg" alt="GrAMPS architecture, part 1">
				</section>
				<section><img class="no-border" src="lib/images/gramps-all-together-2.svg" alt="GrAMPS architecture, part 2">
				</section>
				<section><img class="no-border" src="lib/images/gramps-all-together-3.svg" alt="GrAMPS architecture, part 3">
				</section>
				<section><img class="no-border" src="lib/images/gramps-all-together-4.svg" alt="GrAMPS architecture, part 4">
				</section>
				<section>
					<h2><em>Implementation</em> is easy enough to fit the code on a slide*</h2>
					<small>*sorry the font is so small</small>
				</section>
				<section>
					<h4>Let‚Äôs <em>Upgrade</em> this GraphQL Server</h4>
					<pre style="font-size: 18px;"><code class="js">import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';

import mySchema from './schema';
import myDataAccess from './data';

const app = new Express();
app.use(bodyParser.json());
app.use('/graphql',
  graphqlExpress({
    schema: mySchema,
    context: myDataAccess,
  }),
);
					</code></pre>
				</section>
				<section>
					<h4>Step 1: Import the <em>Middleware</em></h4>
					<pre style="font-size: 18px;"><code class="diff">import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';
+ import gramps from '@gramps/gramps';

import mySchema from './schema';
import myDataAccess from './data';

+ const GraphQLOptions = gramps();

const app = new Express();
app.use(bodyParser.json());
app.use('/graphql',
  graphqlExpress({
    schema: mySchema,
    context: myDataAccess,
  }),
);
					</code></pre>
				</section>
				<section>
					<h4>Step 2: Import the <em>Data Sources</em></h4>
					<pre style="font-size: 18px;"><code class="diff">import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';
import gramps from '@gramps/gramps';

- import mySchema from './schema';
- import myDataAccess from './data';
+ import schemaOne from '@gramps/data-source-one';
+ import schemaTwo from '@gramps/data-source-two';

const GraphQLOptions = gramps();

const app = new Express();
app.use(bodyParser.json());
app.use('/graphql',
  graphqlExpress({
    schema: mySchema,
    context: myDataAccess,
  }),
);
					</code></pre>
				</section>
				<section>
					<h4>Step 3: <em>Combine</em> the Data Sources</h4>
					<pre style="font-size: 18px;"><code class="diff">import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';
import gramps from '@gramps/gramps';

import schemaOne from '@gramps/data-source-one';
import schemaTwo from '@gramps/data-source-two';

const GraphQLOptions = gramps({
+ dataSources: [schemaOne, schemaTwo],
});

const app = new Express();
app.use(bodyParser.json());
app.use('/graphql',
  graphqlExpress({
    schema: mySchema,
    context: myDataAccess,
  }),
);
					</code></pre>
				</section>
				<section>
					<h4>Step 4: Use the New <em>Schema</em> and <em>Context</em></h4>
					<pre style="font-size: 18px;"><code class="diff">import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';
import gramps from '@gramps/gramps';

import schemaOne from '@gramps/data-source-one';
import schemaTwo from '@gramps/data-source-two';

const GraphQLOptions = gramps({
  dataSources: [schemaOne, schemaTwo],
});

const app = new Express();
app.use(bodyParser.json());
+ app.use('/graphql', graphqlExpress(GraphQLOptions));
- app.use('/graphql',
-  graphqlExpress(req => ({
-    schema: req.gramps.schema,
-    context: req.gramps.context,
-  })),
);
					</code></pre>
				</section>
				<section>
					<h4 class="no-margin">Challenge #2:</h4>
					<h2 class="no-margin"><em>Improve</em> Error Handling</h2>
				</section>
				<section>
					<h3 style="width: 110%;margin-left: -5%;">What Makes an Error <em>Helpful</em>?</h3>
					<ul>
						<li class="fragment">Clear description of what went wrong</li>
						<li class="fragment">Clarity about where the error occurred
							<ul>
								<li style="font-size: 90%;">GraphQL errors vs. underlying data access issues</li>
							</ul>
						</li>
						<li class="fragment">Information to help with tracing bugs</li>
						<li class="fragment">Unique IDs shared on the client and server side</li>
					</ul>
				</section>
				<section>
					<h4><em>Client-Side</em> Errors in Development</h4><img class="no-margin" src="lib/images/client-side-error.png" alt="GrAMPS client-side error">
				</section>
				<section>
					<h4>In production, we <strong>can‚Äôt show some data</strong></h4>
					<ul>
						<li class="fragment">Docs link may be behind our firewall</li>
						<li class="fragment">Target endpoint may not be public</li>
					</ul>
				</section>
				<section>
					<h4>Client-Side Errors in <em>Production</em></h4><img class="no-margin" src="lib/images/client-side-error-production.png" alt="GrAMPS client-side error in production">
					<p class="no-margin"><small><code>docsLink</code> and <code>targetEndpoint</code> are removed in production.
							</small></p>
				</section>
				<section>
					<h4>Client and server errors share a <em>GUID</em></h4>
					<pre><code class="sh">
Error: Could not load the given xkcd comic (178460c1-c8d7-42c2-ba0e-f617afb5d3fd)
Description: Could not load the given xkcd comic
Error Code: XKCDModel_Error
GraphQL Model: XKCDModel
Target Endpoint: https://xkcd.com/2000/info.0.json
Documentation: https://ibm.biz/gramps-data-source-tutorial
Data: {
  "id": "2000"
}
					</code></pre>
					<p class="no-margin"><small>Using the GUID, we can find the <code>docsLink</code> and 
							<code>targetEndpoint</code> in the server logs.
							</small></p>
				</section>
				<section>
					<h3 class="u--align-left">This Means...</h3>
					<ul>
						<li class="fragment">Errors are normalized across all data sources</li>
						<li class="fragment">Support tickets can directly reference details in logs</li>
						<li class="fragment">Errors are clear and come with documentation</li>
						<li class="fragment">The source of a given error is immediately clear</li>
					</ul>
				</section>
				<!-- <section>
					<h4>Implementation Is <em>Optional</em> and <em>Easy</em></h4>
					<pre style="font-size: 18px;"><code class="diff">
import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';
import { grampsExpress } from '@gramps/gramps-express';

import schemaOne from '@gramps/data-source-one';
import schemaTwo from '@gramps/data-source-two';

const app = new Express();
app.use(bodyParser.json());
app.use(grampsExpress({ dataSources: [ schemaOne, schemaTwo ] }));
app.use('/graphql',
  graphqlExpress(req => ({
    schema: req.gramps.schema,
    context: req.gramps.context,
+   formatError: req.gramps.formatError,
  })),
);
					</code></pre>
				</section> -->
				<section>
					<h4 class="no-margin">Challenge #3:</h4>
					<h2 class="no-margin">Make Development So <em>Easy</em> Teams Want to Use It</h2>
				</section>
				<section>
					<h3>If we wanted teams to <em>start using GraphQL</em>, we needed it to be 
						<em>dead simple</em> to get started
						
					</h3>
				</section>
				<section>
					<h3>We created a data source <em>starter kit</em>:</h3>
					<ul>
						<li class="fragment">Strong starting point for new data sources</li>
						<li class="fragment">Step-by-step tutorial for building a new data source</li>
						<li class="fragment">Test coverage starts at üíØ</li>
						<li class="fragment">Pre-configured for Travis CI and Code Climate</li>
					</ul>
					<p>
						<small class="fragment">
							<a href="https://github.com/gramps-graphql/data-source-base">github.com/gramps-graphql/data-source-base</a>
						</small>
					</p>
				</section>

				<section>
					<h3>Now, it's even easier!</h3>

					<pre style="font-size: 18px;"><code class="sh">
# Use npx to run the command without having to install anything globally

npx graphql-cli create -b gramps-graphql/data-source-base data-source-mydata
					</code></pre>			
				</section>

				<section>
					<h4>We built a <em>CLI</em> to make development easier</h4>
					<img class="no-margin" src="lib/images/gramps-cli.png" />

					<aside class="notes">
						<ul>
							<li>
								With this, you could run your data source locally, include a gateway to a GraphQL
								server, and even run it with a mock flag if you wanted to generate mock data, using
								mock resolvers.
							</li>
						</ul>
					</aside>
				</section>
				<section>
					<h3>But there was a <strong>snag</strong>:</h3>
					<p class="fragment">‚ÄúHow do we run a local instance of the GraphQL<br>¬µ-service if the data 
						source we‚Äôre developing is already installed? Won‚Äôt they collide?‚Äù
						
					</p>
				</section>
				<section>
					<h3>The solution?</h3>
					<h2>Allow local<br>data sources<br>to <em>override</em></h2>
					<p><code class="sh">gramps dev --data-source .</code></p>
					<aside class="notes">
						We built a CLI to make development easier, then added checks for
						data source name collisions, giving local data sources precedence.
					</aside>
				</section>
				<section>
					<h4>Include a <em>disclaimer</em></h4><img class="no-margin" src="lib/images/data-source-cli.png" alt="GrAMPS warnings for local data sources">
				</section>
				<section>
					<h4 class="no-margin">Challenge #4:</h4>
					<h2 class="no-margin">Build for<br><em>Global</em> Scale</h2>
				</section>
				<section>
					<h3>We didn‚Äôt have to do much</h3>
					<p class="fragment">It turns out Apollo‚Äôs Express server just works.</p>
				</section>
				<section><img src="lib/images/pleasant-surprise.gif" alt="pleasant surprise from The Office">
					<h3 class="no-margin">Which is pretty <em>great</em></h3>
				</section>
				<section>
					<h3>We <em>started</em> working on the GraphQL 
						<span style="text-transform: none;">¬µ</span>-service in <em>May</em>
						
					</h3>
				</section>
				<section>
					<h3>It hit <em>production</em> in <em>July</em></h3>
				</section>

				<section>
					<h3>And we went <em>open source</em> in <em>October</em></h3>
				</section>

				<section>
					<h3>Bonus: Schema Stitching</h3>

					<pre style="font-size: 18px;"><code class="javascript">
export default {
  linkTypeDefs: `extend type SW_Character { memes: SWM_CharacterMemes }`,
  resolvers: mergeInfo => ({
    SW_Character: {
      memes: {
        fragment: `fragment SWMemes on SW_Character { name }`,
        resolve: (parent, args, context, info) =>
          mergeInfo.delegate(
            'query',
            'getMemes',
            { name: parent.name },
            context,
            info,
          ),
      },
    },
  }),
};
					</code></pre>

					<aside class="notes">
						<ul>
							<li>
								Since we went open source with it, one of the nice surpises we noticed about this
								format ended up being schema stitching.
							</li>
							<li>
								If you're unfamiliar schema stitching is the process of taking one GraphQL schema,
								and extending it by adding your own, additional fields.
							</li>
							<li>
								So with GrAMPS, because people can easily share schemas, it made it even easier to
								do this. Which opens up really cool possibilities for combining APIs in new and
								intersting ways, without all of the headache that normally comes along with that.
							</li>
						</ul>
					</aside>
				</section>

				<section><img class="no-border" src="lib/images/GrAMPS-logo.svg" alt="GrAMPS: GraphQL Apollo Microservice Pattern Server" style="max-width: 400px;">
					<h1 class="no-margin">GrAMPS</h1>
					<p><strong>Gr</strong>aphQL 
						<strong>A</strong>pollo 
						<strong>M</strong>icroservice 
						<strong>P</strong>attern 
						<strong>S</strong>erver
						<small>
							<a href="https://github.com/gramps-graphql/gramps">github.com/gramps-graphql/gramps</a> &nbsp; ¬∑ &nbsp; <a href="https://www.npmjs.com/org/gramps">npmjs.com/org/gramps</a>
						</small>
					</p>
				</section>

				<section>
					<h2>Thanks!</h2>
				</section>
				<section class="u--align-left resourcetext">
					<h4>Resources</h4>
					<ol>
						<li><a href="https://github.com/gramps-graphql">GrAMPS on GitHub</a></li>
						<li><a href="https://github.com/gramps-graphql/gramps">GrAMPS Express Middleware</a></li>
						<li><a href="https://gramps-graphql.github.io/gramps-express/">GrAMPS Documentation</a></li>
						<li><a href="https://dev-blog.apollodata.com/how-to-build-graphql-servers-87587591ded5">How to Build GraphQL Servers</a></li>
						<li><a href="https://github.com/gramps-graphql/data-source-base">GrAMPS Data Source Starter Kit</a></li>
						<li><a href="https://ibm.biz/gramps-data-source-tutorial">GrAMPS Data Source Tutorial</a></li>
						<li><a href="https://www.npmjs.com/org/gramps">
								GrAMPS on npm
								</a></li>
					</ol>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
