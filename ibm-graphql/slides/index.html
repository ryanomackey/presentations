<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/carbon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="ibm">
        <span class="ibm__brand">IBM</span> <span class="ibm__product">Cloud</span>
      </div>
			<div class="slides">
				<section>
					<h2>Bringing GraphQL to the Enterprise:</h2>
					<h4>When IBM Met Apollo</h4>
				</section>
				
				<section>
					<h3>About me:</h3>

					<ul>
						<li>Born and raised in Fort Collins, Colorado</li>
						<li>Colorado State University (2013)</li>
						<li>Sold Insurance (2013 - 2016)</li>
						<li>Galvanize (2016)</li>
						<li>IBM (2017)</li>
					</ul>
				</section>

				<section>
						<h3>About Jason:</h3>
	
						<ul>
							<li>Senior developer / front-end architect  at IBM</li>
							<li>Former workaholic / current work-life balance advocate</li>
							<li><em>Obsessed</em> with processes &amp; efficiency</li>
							<li>World's oldest young man</li>
						</ul>
					</section>

				<section>
					<h3>GraphQL is awesome.</h3>
					<h4 class="fragment">Why?</h4>
				</section>

				<section>
					<h2>Because Front-End Development<br>Is <strong>Hard</strong></h2>
				</section>

				<section>
					<h4>Why is front-end development hard?</h4>
					<ul>
						<li class="fragment">More and more app logic is living in the front-end</li>
						<li class="fragment">The front-end is creeping further into the back-end</li>
						<li class="fragment">Our apps have to be <em>fast</em>...</li>
						<li class="fragment">...even on slow and unstable connections</li>
					</ul>
				</section>

				<section>
					<h3>It‚Äôs harder across teams:</h3>
					<ul>
						<li class="fragment">FEDs are dependent on back-end teams</li>
						<li class="fragment">APIs have to exist before UI work can start</li>
						<li class="fragment">If docs are missing or out of date... </li>
						<li class="fragment">...our ‚Äúdocs‚Äù are asking Steve on Slack</li>
					</ul>
				</section>

				<section>
					<h2>Back-end teams <strong>burn</strong> tons of hours supporting FEDs</h2>
					<aside class="notes">
						Back-end teams have to create aggregate API endpoints, deal with the
						pressure of being a bottleneck for other teams, and support other
						developers who don‚Äôt have what they need to get started. All of this
						happens <em>instead</em> of completing their tasks.
					</aside>
				</section>

				<section>
					<h2>Front-end teams <strong>burn</strong> tons of hours getting started</h2>
					<aside class="notes">
						Take a poll in the room: by a show of hands, how many people have wasted
						more than 8 hours trying to get a new UI up and running? Hunting down a 
						way to load data needed to build a UI? On the phone, post a scream emoji.
					</aside>
				</section>

				<section>
					<h3>And if a server goes down...</h3><img src="./images/better-data-layer/server-down.gif" alt="Simpsons taking the system down.">
				</section>
				<section>
					<h3>...we wait.</h3><img src="./images/better-data-layer/waiting.gif" alt="Cookie Monster waiting.">
				</section>
				<section>
					<h2>It can be rough on our <em>users</em>, too.</h2>
				</section>
				<section>
					<div class="forever-aload"><img src="./images/better-data-layer/forever-aload.jpg" alt="Forever a-load."></div>
				</section>
				<section>
					<h2>We can do <em>better</em></h2>
				</section>
				<section>
					<h2>What if we could...</h2>
					<ul>
						<li class="fragment">find all our data in a single place?</li>
						<li class="fragment">test data queries in the browser?</li>
						<li class="fragment">create custom queries with only data we need?</li>
						<li class="fragment">work in parallel with back-end teams?</li>
						<li class="fragment">develop even if the server is down?</li>
						<li class="fragment">show explorable UIs before data is loaded?</li>
						<li class="fragment">render data as it loads instead of all at once?</li>
					</ul>
				</section>
				<section>
					<p><small>(Pause for dramatic effect.)</small></p>
				</section>
				<section>
					<h2>üéâ We can! üéâ</h2>
					<h4>...and <em>GraphQL</em> + <em>React</em> make it easy</h4>
				</section>
				<section>
					<h4>Interactive Online <em>Documentation</em></h4><img class="no-margin" src="./images/better-data-layer/graphql-playground.png" alt="GraphQL Playground.">
					<p class="no-margin">Guaranteed to be up-to-date!</p>
				</section>
				<section>
					<h4><em>Test Queries</em> in the Browser</h4><img class="no-margin" src="./images/better-data-layer/full-query.png" alt="GraphQL query and result.">
					<p class="no-margin">This is copy-pasteable into your app.</p>
				</section>
				<section>
					<h4>Load <em>Only</em> Data We Need</h4><img class="no-margin" src="./images/better-data-layer/query-test.png" alt="GraphQL Playground query with only a few fields.">
					<p class="no-margin">No wasted data transfer.</p>
				</section>
				<section>
					<h4>Work <em>Offline</em></h4><img class="no-margin" src="./images/better-data-layer/mock-data.png" alt="GraphQL query using mock data.">
					<p class="no-margin">Get realistic, variable mock data.</p>
				</section>
				<section>
					<h2>Adding data to the UI is a breeze üëå</h2>
				</section>
				<section><img class="no-margin no-border" src="./images/better-data-layer/react-with-data.png" alt="React component using GraphQL query.">
				</section>
				<section>
					<h4><em>Loading states</em> are basically free</h4><img class="no-margin no-border" src="./images/better-data-layer/loading-pattern.png" alt="Loading and error properties.">
				</section>
				<section>
					<h4><em>Skeleton</em> components üíÄ are even better</h4><img class="no-margin no-border" src="./images/better-data-layer/skeleton-pattern.png" alt="Loading class for skeleton components.">
				</section>
				<section>
					<h4>Skeleton components let us render an explorable UI <em>before</em> data is loaded</h4>
					<p class="codepen" data-height="396" data-theme-id="0" data-slug-hash="NabRVb" data-default-tab="result" data-user="jlengstorf" data-embed-version="2" data-pen-title="Skeleton Loading Pattern Example" style="min-height: 350px;">See the Pen <a href="https://codepen.io/jlengstorf/pen/JMVYoa/">Skeleton Loading Pattern Example for Links</a> by Jason Lengstorf (<a href="https://codepen.io/jlengstorf">@jlengstorf</a>) on <a href="https://codepen.io">CodePen</a>.</p>
					<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
				</section>
				<section>
					<h4>We can also show data <em>as it arrives</em></h4><img class="no-margin no-border" src="./images/better-data-layer/deferred.png" alt="Deferred data loading.">
				</section>
				<section>
					<h2>Case Study:</h2>
					<h4>IBM Cloud Account Usage Dashboard</h4>
				</section>
				<section>
					<video src="./video/2017-06-08-comparison_first-load.mp4" controls></video>
				</section>
				<section>
					<video src="./video/2017-06-08-comparison_switch-account.mp4" controls></video>
				</section>

				<!-- GrAMPS -->

				<section>
					<h3>I wanted to start using it in production <em>immediately</em></h3>
					<aside class="notes">
						I‚Äôm slow to pick up new ideas, but once I decide something is the right
						path forward, I want to go all-in. So after I did my initial research on
						the pros and cons of GraphQL and decided it was a smart move, I
						immediately started telling everyone that we needed to change everything,
						right away.
						
					</aside>
				</section>
				<section><img src="./images/graphql-microservices/nope.gif" alt="nope">
					<h3 class="no-margin">Not everyone was on board</h3>
					<aside class="notes">
						Other teams immediately started voicing concerns, and a number of really
						good questions were raised. And it‚Äôs a good thing, too, because I was only
						thinking about the end ‚Äî not the path we‚Äôd have to follow to get there.
						
					</aside>
				</section>
				<section>
					<h4>Before we get into the details,<br>let me set the scene&hellip;</h4>
					<aside class="notes">
						Before I bring up the questions that were asked, let me give you some
						insight into the way things are structured on our product.
						
					</aside>
				</section>
				<section>
					<h3>How <em>IBM Cloud</em> is built:</h3>
					<ul>
						<li class="fragment">Node ¬µ-service architecture</li>
						<li class="fragment">30+ ¬µ-service teams</li>
						<li class="fragment">Each ¬µ-service (‚Äúplugin‚Äù) is a separate codebase</li>
						<li class="fragment">Teams control their own workflow</li>
					</ul>
					<aside class="notes">
						Teams basically have full autonomy to build however they want. This is
						great for empowering our teams, but it‚Äôs led to consistency problems.
						Documentation is spotty, hidden in wikis, and usually incomplete and/or
						out of date. You have to know someone who knows someone to get help
						fetching data from a new back-end service. Developers can‚Äôt help out
						other teams because the codebases are so different that it takes too long
						to get familiar with a new plugin.
						
					</aside>
				</section>
				<section>
					<h3>This has its <strong>downsides</strong>:</h3>
					<ul>
						<li class="fragment">Things can change in 30+ directions at any given time</li>
						<li class="fragment">Front-ends need data from multiple ¬µ-services</li>
						<li class="fragment">Internal documentation &amp; architecture is inconsistent</li>
						<li class="fragment">Code can be wildly inconsistent between ¬µ-services</li>
					</ul>
					<aside class="notes">
						There are too many moving parts for anyone to know exactly what‚Äôs
						going on at any given time. If a team makes a breaking change, it‚Äôs
						nearly impossible to let everyone know ‚Äî so typically teams just break
						shit and wait for people to ask. If a data source we rely on changes,
						we need to figure out who owns it and hope that the documentation is
						clear enough to solve our problem ‚Äî and that‚Äôs not always the case.
						And since each codebase is completely different, it can be extremely
						time-consuming to attempt to send pull requests that don‚Äôt introduce
						new bugs. (That‚Äôs a topic for another talk, though.)
						
					</aside>
				</section>
				<section>
					<h3 style="width: 110%; margin-left: -5%;">GraphQL has <em>solutions</em>:</h3>
					<ul>
						<li class="fragment">Changes are centralized in the GraphQL ¬µ-service</li>
						<li class="fragment">Data access happens through a single endpoint</li>
						<li class="fragment">Documentation is centralized and consistent</li>
						<li class="fragment">Cleaner separation between data and presentation</li>
					</ul>
				</section>
				<section>
					<h3 style="width: 110%; margin-left: -5%;">But there are <strong>complications</strong>:</h3>
					<ul>
						<li class="fragment">Who ‚Äúowns‚Äù the GraphQL ¬µ-service?</li>
						<li class="fragment">How can teams make independent changes?</li>
						<li class="fragment">Can one bad commit take down the whole service?</li>
						<li class="fragment">Doesn‚Äôt an extra layer make it harder to trace errors?</li>
					</ul>
				</section>
				<section>
					<h3>We wanted the <em>benefits</em> of GraphQL&hellip;<span class="fragment"> but could we afford the trade-offs?</span></h3>
				</section>
				<section>
					<h2>We needed <em>answers</em></h2>
				</section>
				<section>
					<h3 class="u--align-left">Can we...</h3>
					<ol>
						<li class="fragment">Centralize data, but let teams keep control?</li>
						<li class="fragment">Design an approach that <em>improves</em> error handling?</li>
						<li class="fragment">Make it so easy teams <em>want</em> to switch?</li>
						<li class="fragment">Build a service that can handle IBM‚Äôs scale?</li>
					</ol>
					<aside class="notes">
						I knew that GraphQL was in production at Facebook, GitHub, and several 
						other companies at IBM‚Äôs scale, but what we <em>didn‚Äôt</em> know was how much
						hard work goes into making it run. Did we need a whole team just for
						managing scalability? Would we need to spend a fortune on infrastructure
						to make it feasible?
						
					</aside>
				</section>
				<section>
					<h4 class="no-margin">Challenge #1:</h4>
					<h2 class="no-margin"><em>Centralize</em> Data, but <em>Decentralize</em> Control</h2>
				</section>
				<section>
					<h3>The ideal <em>solution</em>:</h3>
					<p><span>Each team maintains their own GraphQL schema...</span><br><span class="fragment"> but that schema is aggregated by a central ¬µ-service.</span></p>
				</section>
				<section>
					<h3 style="width: 110%;max-width: 110%; margin-left: -5%;">If this was going to work, we needed a <em>standardized format</em> 
						for sharing schemas.
						
					</h3>
					<aside class="notes">
						In general, the GraphQL community talks about server-side GraphQL as a
						schema, a set of resolvers, and then code that you have to figure out on
						your own to get data. But Jonas Helfer suggested additional abstractions:
						Models and Connectors. We started with that and built a boilerplate for 
						adding data to GraphQL servers.
						
					</aside>
				</section>
				<section>
					<h2>We call these<br><em>Data Sources</em></h2>
				</section>
				<section><img class="no-border" src="./images/graphql-microservices/gramps-data-source-1.svg" alt="GrAMPS data source, part 1">
				</section>
				<section><img class="no-border" src="./images/graphql-microservices/gramps-data-source-2.svg" alt="GrAMPS data source, part 2">
				</section>
				<section><img class="no-border" src="./images/graphql-microservices/gramps-data-source-3.svg" alt="GrAMPS data source, part 3">
				</section>
				<section><img class="no-border" src="./images/graphql-microservices/gramps-data-source-4.svg" alt="GrAMPS data source, part 4">
				</section>
				<section><img class="no-border" src="./images/graphql-microservices/gramps-data-source-5.svg" alt="GrAMPS data source, part 5">
				</section>
				<section>
					<h3>Each data source is an <em>independent</em> GitHub repo, which means:</h3>
					<ul class="align-center">
						<li class="fragment">‚úÖ No bottlenecks<br><small>Each team commits and deploys code independently.</small></li>
						<li class="fragment">‚úÖ No loss of control<br><small>Each team owns their data source.</small></li>
						<li class="fragment">‚úÖ No accidental borking<br><small>Each team‚Äôs code has individual test suites.</small></li>
					</ul>
				</section>
				<section>
					<h3>How do we <em>combine</em> the data sources?</h3>
					<aside class="notes">
						<ul>
							<li>The GraphQL ¬µ-service core is an empty schema</li>
							<li>Each data source is an npm package, which is added as a dependency</li>
							<li>
								Express middleware composes the data sources into a single set of 
								arguments for use with the Apollo Express server
								
							</li>
						</ul>
					</aside>
				</section>
				<section><img class="no-border" src="./images/graphql-microservices/gramps-all-together-1.svg" alt="GrAMPS architecture, part 1">
				</section>
				<section><img class="no-border" src="./images/graphql-microservices/gramps-all-together-2.svg" alt="GrAMPS architecture, part 2">
				</section>
				<section><img class="no-border" src="./images/graphql-microservices/gramps-all-together-3.svg" alt="GrAMPS architecture, part 3">
				</section>
				<section><img class="no-border" src="./images/graphql-microservices/gramps-all-together-4.svg" alt="GrAMPS architecture, part 4">
				</section>
				<section>
					<h2><em>Implementation</em> is easy enough to fit the code on a slide</h2>
				</section>
				<section>
					<h4>Let‚Äôs <em>Upgrade</em> this GraphQL Server</h4>
					<pre style="font-size: 18px;"><code class="js">
import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';

import mySchema from './schema';
import myDataAccess from './data';

const app = new Express();
app.use(bodyParser.json());
app.use('/graphql',
	graphqlExpress({
		schema: mySchema,
		context: myDataAccess,
	}),
);
					</code></pre>
				</section>
				<section>
					<h4>Step 1: Import the <em>Middleware</em></h4>
					<pre style="font-size: 18px;"><code class="diff"> 
import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';
+ import { grampsExpress } from '@gramps/gramps-express';

import mySchema from './schema';
import myDataAccess from './data';

const app = new Express();
app.use(bodyParser.json());
app.use('/graphql',
	graphqlExpress({
		schema: mySchema,
		context: myDataAccess,
	}),
);
					</code></pre>
				</section>
				<section>
					<h4>Step 2: Import the <em>Data Sources</em></h4>
					<pre style="font-size: 18px;"><code class="diff">
import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';
import { grampsExpress } from '@gramps/gramps-express';

- import mySchema from './schema';
- import myDataAccess from './data';
+ import schemaOne from '@gramps/data-source-one';
+ import schemaTwo from '@gramps/data-source-two';

const app = new Express();
app.use(bodyParser.json());
app.use('/graphql',
	graphqlExpress({
		schema: mySchema,
		context: myDataAccess,
	}),
);
					</code></pre>
				</section>
				<section>
					<h4>Step 3: <em>Combine</em> the Data Sources</h4>
					<pre style="font-size: 18px;"><code class="diff">
import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';
import { grampsExpress } from '@gramps/gramps-express';

import schemaOne from '@gramps/data-source-one';
import schemaTwo from '@gramps/data-source-two';

const app = new Express();
app.use(bodyParser.json());
+ app.use(grampsExpress({ dataSources: [ schemaOne, schemaTwo ] }));
app.use('/graphql',
	graphqlExpress({
		schema: mySchema,
		context: myDataAccess,
	}),
);
					</code></pre>
				</section>
				<section>
					<h4>Step 4: Use the New <em>Schema</em> and <em>Context</em></h4>
					<pre style="font-size: 18px;"><code class="diff">
import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';
import { grampsExpress } from '@gramps/gramps-express';

import schemaOne from '@gramps/data-source-one';
import schemaTwo from '@gramps/data-source-two';

const app = new Express();
app.use(bodyParser.json());
app.use(grampsExpress({ dataSources: [ schemaOne, schemaTwo ] }));
app.use('/graphql',
+   graphqlExpress(req => ({
+     schema: req.gramps.schema,
+     context: req.gramps.context,
+   })),
);
					</code></pre>
				</section>
				<section>
					<h4 class="no-margin">Challenge #2:</h4>
					<h2 class="no-margin"><em>Improve</em> Error Handling</h2>
				</section>
				<section>
					<h3 style="width: 110%;margin-left: -5%;">What Makes an Error <em>Helpful</em>?</h3>
					<ul>
						<li class="fragment">Clear description of what went wrong</li>
						<li class="fragment">Clarity about where the error occurred
							<ul>
								<li style="font-size: 90%;">GraphQL errors vs. underlying data access issues</li>
							</ul>
						</li>
						<li class="fragment">Information to help with tracing bugs</li>
						<li class="fragment">Unique IDs shared on the client and server side</li>
					</ul>
				</section>
				<section>
					<h4><em>Client-Side</em> Errors in Development</h4><img class="no-margin" src="./images/graphql-microservices/client-side-error.png" alt="GrAMPS client-side error">
				</section>
				<section>
					<h4>In production, we <strong>can‚Äôt show some data</strong></h4>
					<ul>
						<li class="fragment">Docs link may be behind our firewall</li>
						<li class="fragment">Target endpoint may not be public</li>
					</ul>
				</section>
				<section>
					<h4>Client-Side Errors in <em>Production</em></h4><img class="no-margin" src="./images/graphql-microservices/client-side-error-production.png" alt="GrAMPS client-side error in production">
					<p class="no-margin"><small><code>docsLink</code> and <code>targetEndpoint</code> are removed in production.
							</small></p>
				</section>
				<section>
					<h4>Client and server errors share a <em>GUID</em></h4>
					<pre><code class="sh">
Error: Could not load the given xkcd comic (178460c1-c8d7-42c2-ba0e-f617afb5d3fd)
Description: Could not load the given xkcd comic
Error Code: XKCDModel_Error
GraphQL Model: XKCDModel
Target Endpoint: https://xkcd.com/2000/info.0.json
Documentation: https://ibm.biz/gramps-data-source-tutorial
Data: {
	"id": "2000"
}
					</code></pre>
					<p class="no-margin"><small>Using the GUID, we can find the <code>docsLink</code> and 
							<code>targetEndpoint</code> in the server logs.
							</small></p>
				</section>
				<section>
					<h3 class="u--align-left">This Means...</h3>
					<ul>
						<li class="fragment">Errors are normalized across all data sources</li>
						<li class="fragment">Support tickets can directly reference details in logs</li>
						<li class="fragment">Errors are clear and come with documentation</li>
						<li class="fragment">The source of a given error is immediately clear</li>
					</ul>
				</section>
				<section>
					<h4>Implementation Is <em>Optional</em> and <em>Easy</em></h4>
					<pre style="font-size: 18px;"><code class="diff">
import Express from 'express';
import bodyParser from 'body-parser';
import { graphqlExpress } from 'apollo-server-express';
import { grampsExpress } from '@gramps/gramps-express';

import schemaOne from '@gramps/data-source-one';
import schemaTwo from '@gramps/data-source-two';

const app = new Express();
app.use(bodyParser.json());
app.use(grampsExpress({ dataSources: [ schemaOne, schemaTwo ] }));
app.use('/graphql',
	graphqlExpress(req => ({
		schema: req.gramps.schema,
		context: req.gramps.context,
+     formatError: req.gramps.formatError,
	})),
);
					</code></pre>
				</section>
				<section>
					<h4 class="no-margin">Challenge #3:</h4>
					<h2 class="no-margin">Make Development So <em>Easy</em> Teams Want to Use It</h2>
				</section>
				<section>
					<h3>If we wanted teams to <em>start using GraphQL</em>, we needed it to be 
						<em>dead simple</em> to get started
						
					</h3>
				</section>
				<section>
					<h3>We created a data source <em>starter kit</em>:</h3>
					<ul>
						<li class="fragment">Strong starting point for new data sources</li>
						<li class="fragment">Step-by-step tutorial for building a new data source</li>
						<li class="fragment">Test coverage starts at üíØ</li>
						<li class="fragment">Pre-configured for Travis CI and Code Climate</li>
					</ul>
					<p><small class="fragment"><a href="https://github.com/gramps-graphql/data-source-base">
								github.com/gramps-graphql/data-source-base
								</a></small></p>
				</section>
				<section>
					<h4>We built a <em>CLI</em> to make development easier</h4>
					<pre><code class="sh">
$ gramps --live

============================================================
		GrAMPS is running in live mode on port 8080

		GraphiQL: http://localhost:8080/graphiql
============================================================
					</code></pre>
				</section>
				<section>
					<h3>But there was a <strong>snag</strong>:</h3>
					<p class="fragment">‚ÄúHow do we run a local instance of the GraphQL<br>¬µ-service if the data 
						source we‚Äôre developing is already installed? Won‚Äôt they collide?‚Äù
						
					</p>
				</section>
				<section>
					<h3>The solution?</h3>
					<h2>Allow local<br>data sources<br>to <em>override</em></h2>
					<p><code class="sh">gramps --data-source-dir ./</code></p>
					<aside class="notes">
						We built a CLI to make development easier, then added checks for
						data source name collisions, giving local data sources precedence.
						
					</aside>
				</section>
				<section>
					<h4>But add a <em>warning</em></h4><img class="no-margin" src="./images/graphql-microservices/local-data-source-warnings-pt1.png" alt="GrAMPS warnings for local data sources">
					<p class="no-margin"><small>Clarified text and updated links are coming (<a href="https://github.com/gramps-graphql/gramps-express/issues/36">#36</a>)</small></p>
				</section>
				<section>
					<h4>Actually, add <em>two</em> warnings</h4><img class="no-margin" src="./images/graphql-microservices/local-data-source-warnings-pt2.png" alt="GrAMPS warnings for local data sources">
					<p class="no-margin"><small>Clarified text and updated links are coming (<a href="https://github.com/gramps-graphql/gramps-express/issues/36">#36</a>)</small></p>
				</section>
				<section>
					<h4 class="no-margin">Challenge #4:</h4>
					<h2 class="no-margin">Build for<br><em>Global</em> Scale</h2>
				</section>
				<section>
					<h3>We didn‚Äôt have to do much</h3>
					<p class="fragment">It turns out Apollo‚Äôs Express server just works.</p>
				</section>
				<section><img src="./images/graphql-microservices/pleasant-surprise.gif" alt="pleasant surprise from The Office">
					<h3 class="no-margin">Which is pretty <em>great</em></h3>
				</section>
				<section>
					<h3>We <em>started</em> working on the GraphQL 
						<span style="text-transform: none;">¬µ</span>-service in <em>May</em>
						
					</h3>
				</section>
				<section>
					<h3>It hit <em>production</em> in <em>July</em></h3>
				</section>
				<section>
					<h3>After the dust settled,<br>we realized <em>two things</em></h3>
				</section>
				<section>
					<h2>#1</h2>
					<p>
						‚ÄúIf everyone wrote their data sources using this format, the 
						dev community could share GraphQL data sources as easily as we share 
						npm packages.‚Äù
						
					</p>
				</section>
				<section>
					<h2>#2</h2>
					<p>‚ÄúThis might be useful to other people.‚Äù</p>
				</section>
				<section>
					<h2>So we<br>released it under the <em>MIT license</em></h2>
					<h2>üéâ</h2>
				</section>
				<section><img class="no-border" src="./images/graphql-microservices/GrAMPS-logo.svg" alt="GrAMPS: GraphQL Apollo Microservice Pattern Server" style="max-width: 400px;">
					<h1 class="no-margin">GrAMPS</h1>
					<p><strong>Gr</strong>aphQL 
						<strong>A</strong>pollo 
						<strong>M</strong>icroservice 
						<strong>P</strong>attern 
						<strong>S</strong>erver
						<small>
							<a href="https://github.com/gramps-graphql/gramps-express">github.com/gramps-graphql/gramps-express</a> &nbsp; ¬∑ &nbsp; <a href="https://www.npmjs.com/org/gramps">npmjs.com/org/gramps</a>
						</small>
					</p>
				</section>
				<section>
					<h2>Thanks!</h2>
				</section>
				<section class="u--align-left resourcetext">
					<h4>Resources</h4>
					<ol>
						<li><a href="https://github.com/gramps-graphql">GrAMPS on GitHub</a></li>
						<li><a href="https://github.com/gramps-graphql/gramps-express">GrAMPS Express Middleware</a></li>
						<li><a href="https://gramps-graphql.github.io/gramps-express/">GrAMPS Documentation</a></li>
						<li><a href="https://dev-blog.apollodata.com/how-to-build-graphql-servers-87587591ded5">How to Build GraphQL Servers</a></li>
						<li><a href="https://github.com/gramps-graphql/data-source-base">GrAMPS Data Source Starter Kit</a></li>
						<li><a href="https://ibm.biz/gramps-data-source-tutorial">GrAMPS Data Source Tutorial</a></li>
						<li><a href="https://www.npmjs.com/org/gramps">
								GrAMPS on npm
								</a></li>
					</ol>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
